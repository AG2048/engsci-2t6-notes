\section{L08}
Oct 4, 2023
\begin{itemize}
	\item Counting Sort / Bucket Sort
		\begin{theorem}
			A = array with numbers in range 0 to $k$. Total run time is $\mathcal O(n+k)$. Assuming if $k = \mathcal O(n)$, then the run time is $\mathcal O(n)$.
			 \begin{lstlisting}
c[i] = 0 for i = 0 to k
for i = 1: length(A)   (O(n))
    c[A[i]] = c[A[i]] + 1
for i = 1:k  (O(k))
    c[i] = c[i] + c[i-1]
for i = length(A) down to 1  (O(n))
    B[c[A[i]]] = A[i]
	c[A[i]] = c[A[i]] - 1

			\end{lstlisting}
			Idea is: we count number of occurrences of each number in the array into c. Then we accumulate the counts. Then we find each element in A, cumulative count indicate position of this element in B.\\
			The key idea is: the total count remains same if no element is between the number smaller than i and i. So its value tells what "RANK" the number is.\\
			The c array counts "how many numbers are in each tier". Then adds up to get the "rank" of each value. Then for each number, we find its "rank", put the number in location according to its rank, and reduce rank by 1 for next number.
		\end{theorem}
	\item RADIX SORT (Stable Sorting)
		\begin{theorem}
			\begin{lstlisting}
for i = LSB to MSB
	count sort on digit i
				\end{lstlisting}
				n = numbers to sort\\
				k = range of digits\\
				d = number of digits\\
				one pass = O(n+k)\\
				total is d digits so $\mathcal O(d(n+k))$\\
				Idea is to sort by each digit from LSB to MSB. Since counting sort is stable, the order of the digits are preserved.\\
				\end{theorem}
			\item Search for ith largest element in O(n) expected time.
				\begin{theorem}
					To find largest element, we need n-1 comparisons.\\
					If we have a tree splitting into smaller and larger, then to find the 2nd max requires additional comparisons of log(n).\\
					then kth max gives O(n + k log n)\\
					\\
					To find min given that tree, we need additional n/2 - 1 comparisons.\\
					\begin{lstlisting}
Rand_Select(A, p, r, i)
	if p == r then return A[p]
	q = Rand_Partition(A, p, r)
	k = q - p + 1
	if i <= k then return Rand_Select(A, p, q, i)
	else return Rand_Select(A, q+1, r, i-k)
					\end{lstlisting}
				\end{theorem}
			\item Binary Search Tree:
				\begin{theorem}
					Binary tree with key(left_child)$ <$ key(parent)$ < $key(right_child)\\
					To search, start from root, if key is smaller, go left, if key is larger, go right.\\
					To sort:
					\begin{lstlisting}
Run in order from LEFT MOST to RIGHT MOST
visit left
print
visit right
print
					\end{lstlisting}
					Insert: search and place it as a leaf.\\
					Build BST:
					for each element, insert it into the tree.\\
					Note the sequence you insert can affect the shape of the tree.\\
					HOW TO DELETE FROM TREE:\\
					SEARCH KEY\\
					Case 1: it's a leaf. Delete it\\
					Case 2: it has ONE child, delete it, and LIFT the child up.\\
					Case 3: has two children: find successor by going right once, then go left as far as possible.\\
					Then swap the successor with the node to be deleted.\\ (O(h)) case\\
					Sort is O(n)\\
					Insert is O(h)\\
					Search is O(h)\\
					Built is O(nh)\\
					If we have structurally balanced BST, h = log(n)\\
					There are AVL, 2-3, Red-Black trees, B-trees, etc.\\
				\end{theorem}

\end{itemize}
